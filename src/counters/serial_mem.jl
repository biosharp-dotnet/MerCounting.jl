
"""
    serial_mem(::Type{M}, input::DatastoreBuffer{<:ReadDatastore}, count_mode::CountMode, range::AbstractRange = 1:length(input)) where {M<:AbstractMer}

MerCounting's simplest kmer counting method.

Build a sorted list (vector) of kmer counts (MerCount), serially and entirely in memory.

!!! warning
    This function is a serial and in memory `MerCount` list builder that can build a
    kmer count from a ReadsDatastore on its own (if you have memory and time),
    but it is also intended to be composed into other multi-process or multi-threaded
    kmer counting strategies.

    This method estimates roughly how many kmers will be generated by the reads
    specified by `range` in the dataset. It then pre-allocates an array to contain
    them. It then collects the kmers, sorts, them, and then collapses them into a
    list of counts sorted by the kmer.
    
    So if you want to count kmers and have the resources to throw at it, this is
    the simplest method, and possibly even the quickest given that simplicity.
"""
function serial_mem(::Type{M}, input::DatastoreBuffer{<:ReadDatastore}, count_mode::CountMode, range::AbstractRange = 1:length(input)) where {M<:AbstractMer}
    @info "Collecting kmers from $(length(range)) reads in read datastore $(name(ReadDatastores.datastore(input)))"
    all_mers = collect_mers(M, count_mode, input, range)
    @info "Collapsing collected kmers into counts"
    return collapse_into_counts(all_mers)
end

"""
    serial_mem(::Type{M}, input::ReadDatastore, count_mode::CountMode, range::AbstractRange = 1:length(input)) where {M<:AbstractMer}

MerCounting's simplest kmer counting method.

Build a sorted list (vector) of kmer counts (MerCount), serially and entirely in memory.

!!! warning
    This function is a serial and in memory `MerCount` list builder that can build a
    kmer count from a ReadsDatastore on its own (if you have memory and time),
    but it is also intended to be composed into other multi-process or multi-threaded
    kmer counting strategies.
    
    This method estimates roughly how many kmers will be generated by the reads
    specified by `range` in the dataset. It then pre-allocates an array to contain
    them. It then collects the kmers, sorts, them, and then collapses them into a
    list of counts sorted by the kmer.
    
    So if you want to count kmers and have the resources to throw at it, this is
    the simplest method, and possibly even the quickest given that simplicity.
"""
function serial_mem(::Type{M}, input::ReadDatastore, count_mode::CountMode, range::AbstractRange = 1:length(input)) where {M<:AbstractMer}
    return serial_mem(M, buffer(input), count_mode, range)
end

#=
macro serial_mem(K::Int, count_mode::Symbol, filename::String, range::Expr)
    # Figure out type of read datastore
    dstype = ReadDatastores.deduce_datastore_type(filename)
    # Process the range argument
    @assert range.head === :call
    @assert range.args[1] === :(:)
    interval = range.args[2]:range.args[3]
    quote
        open($dstype, $filename) do ds
            serial_mem(DNAMer{$K}, $count_mode, ds, $interval)
        end
    end
end
=#